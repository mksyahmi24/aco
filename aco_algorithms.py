# -*- coding: utf-8 -*-
"""aco_algorithms.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X6JxjmM3jJXixeiQ2X-rBko3HU2tfDDC
"""

import random
import numpy as np
import pandas as pd

# Function to load data from a CSV file
def load_data(file_path):
    """Loads data from a CSV file and returns a list of values from the first column."""
    try:
        df = pd.read_csv(file_path)
        return df.iloc[:, 0].tolist()
    except FileNotFoundError:
        print(f"Error: File not found at path: {file_path}")
        return []

# Load data from CSV files
students = load_data('/content/students.csv')
instructors = load_data('/content/instructors.csv')
courses = load_data('/content/courses.csv')
classrooms = load_data('/content/classrooms.csv')
timeslots = load_data('/content/timeslots.csv')

# Parameters for ACO
num_ants = 10
num_iterations = 100
alpha = 1.0  # Pheromone importance
beta = 2.0   # Heuristic importance
evaporation_rate = 0.5  # Pheromone evaporation rate
Q = 100  # Constant for pheromone update

# Initialize pheromone matrix
pheromone = np.ones((len(courses), len(instructors), len(classrooms), len(timeslots)))

# Heuristic information: Inverse of conflicts for a given assignment
def heuristic_value(course, instructor, classroom, timeslot):
    return 1.0

# Fitness function
def fitness(schedule):
    instructor_conflicts = len(schedule) - len(set((c[1], c[3]) for c in schedule))
    room_conflicts = len(schedule) - len(set((c[2], c[3]) for c in schedule))
    return instructor_conflicts + room_conflicts

# Construct a solution

def construct_solution():
    solution = []
    for course in courses:
        probabilities = []
        for instructor in instructors:
            for classroom in classrooms:
                for timeslot in timeslots:
                    pheromone_value = pheromone[courses.index(course)][instructors.index(instructor)][classrooms.index(classroom)][timeslots.index(timeslot)]
                    heuristic = heuristic_value(course, instructor, classroom, timeslot)
                    probabilities.append((course, instructor, classroom, timeslot, pheromone_value ** alpha * heuristic ** beta))

        # Normalize probabilities and select an assignment
        total = sum(p[4] for p in probabilities)
        probabilities = [(p[0], p[1], p[2], p[3], p[4] / total) for p in probabilities]
        chosen = random.choices(probabilities, weights=[p[4] for p in probabilities], k=1)[0]
        solution.append((chosen[0], chosen[1], chosen[2], chosen[3]))

    return solution

# Main ACO loop
best_solution = None
best_fitness = float('inf')

for iteration in range(num_iterations):
    solutions = []
    solution_fitness = []

    # Generate solutions with ants
    for _ in range(num_ants):
        solution = construct_solution()
        solutions.append(solution)
        solution_fitness.append(fitness(solution))

    # Update best solution
    min_fitness_index = np.argmin(solution_fitness)
    if solution_fitness[min_fitness_index] < best_fitness:
        best_solution = solutions[min_fitness_index]
        best_fitness = solution_fitness[min_fitness_index]

    # Update pheromones
    pheromone *= (1 - evaporation_rate)  # Evaporation

    for solution, fit in zip(solutions, solution_fitness):
        for assignment in solution:
            course_idx = courses.index(assignment[0])
            instructor_idx = instructors.index(assignment[1])
            classroom_idx = classrooms.index(assignment[2])
            timeslot_idx = timeslots.index(assignment[3])
            pheromone[course_idx][instructor_idx][classroom_idx][timeslot_idx] += Q / fit

    print(f"Iteration {iteration + 1}: Best Fitness = {best_fitness}")

print("\nOptimal Timetable:")
for course in best_solution:
    print(f"Course {course[0]} - Instructor {course[1]} - Room {course[2]} - Timeslot {course[3]}")